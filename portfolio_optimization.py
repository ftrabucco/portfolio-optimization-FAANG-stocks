# -*- coding: utf-8 -*-
"""portfolio_optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N6ykTO0B5ZG-_XdelIBka4sOaEyGYbYM

#  This program attempts to optimize a users portfolio usign the efficient frotier
"""

# import the python libraries

from pandas_datareader import data as web
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

#Get the stock symbols/ tickers in the portfolio
#FAANG 
assets=['FB','AMZN','AAPL','NFLX','GOOG']

#Assing weights to the stocks.
weights = np.array([0.2,0.2,0.2,0.2,0.2])

#Get the stock/portfolio starting date
stockStartDate='2013-01-01'

# Get the stocks ending date (today)
today=datetime.today().strftime('%Y-%m-%d')
today

# Create a dataframe to store the adjusted close price of the stocks
df= pd.DataFrame()

#Store the adjusted close price of the stock into the df
for stock in assets:
  df[stock]=web.DataReader(stock, data_source='yahoo', start=stockStartDate, end = today)['Adj Close']

# Show the df
df

# Create the title 'Portfolio Adj Close Price History
title = 'Portfolio Adj. Close Price History    '

#Get the stocks
my_stocks = df

#Create and plot the graph
plt.figure(figsize=(12.2,4.5)) #width = 12.2in, height = 4.5

# Loop through each stock and plot the Adj Close for each day
for c in my_stocks.columns.values:
  plt.plot( my_stocks[c],  label=c)#plt.plot( X-Axis , Y-Axis, line_width, alpha_for_blending,  label)
plt.title(title)
plt.xlabel('Date',fontsize=18)
plt.ylabel('Adj. Price USD ($)',fontsize=18)
plt.legend(my_stocks.columns.values, loc='upper left')
plt.show()

# Show the daily simple return 
returns = df.pct_change()
returns

# Create and show the annualized coveriance matrix
cov_matrix_annual = returns.cov() * 252
cov_matrix_annual

# Calculate the portfolio variance
port_variance = np.dot(weights.T, np.dot(cov_matrix_annual, weights))
port_variance

# Calculate the portfolio volatility aka standard deviation
port_volatility = np.sqrt(port_variance)
port_volatility

# Calculate the annual portfolio return 
portfolioSimpleAnnualReturn = np.sum(returns.mean() * weights) * 252
portfolioSimpleAnnualReturn

# Show the expected annual return, volatility (risk), and variance

percent_var = str(round(port_variance,2)*100)+'%'
percent_vols = str(round(port_volatility,2)*100)+'%'
percent_ret = str(round(portfolioSimpleAnnualReturn,2)*100)+'%'

print('Expected annual return: ' + percent_ret)
print('Annual volatility/risk: '+ percent_vols)
print('Annual variance: '+percent_var)

pip install PyPortfolioOpt

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns

# Portfolio Optimization !

# Calculate the expected returns and the annualised sample covariance matrix of asset returns
mu = expected_returns.mean_historical_return(df)
S = risk_models.sample_cov(df)

# Optimize for max sharp ratio
ef = EfficientFrontier(mu,S)
weights = ef.max_sharpe()
cleaned_weights = ef.clean_weights()
print(cleaned_weights)
ef.portfolio_performance(verbose = True)

0.07921 + 0.30355 + 0.27174 + 0.3455 + 0.0

# Get the discrete alocation of each share per stock
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

latest_prices=get_latest_prices(df)
weights = cleaned_weights
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value=15000)

allocation, leftover = da.lp_portfolio()
print('Discrete allocation: ', allocation)
print('Funds remaining: ${:.2f}'.format(leftover))

